\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{amsthm}
\usepackage{subfig}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[left=2.0cm, right=2.0cm, top=2.50cm, bottom=2.5cm]{geometry}
\author{Nicolas VUAILLE}
\title{Algorithme de propagation}
\date{\today}

\newtheorem{presup}{Hypothèse}

\begin{document}
\maketitle

\section*{Abstract}

La cohérence temporelle d'un scenario interactif est un problème épineux. Si une analyse statique permet déjà de voir les potentiels problèmes, une correction en amont n'est pas forcément bienvenue : le fait d'avoir des branches conditionnelles peut lors de l'exécution libérer le scenario de certaines contraintes et rendre possible des exécutions qui ne le semblaient pas. Une analyse lors de l'exécution est donc nécessaire. \\

Cependant il semble que l'on ai assez d'informations pour anticiper les problèmes, et potentiellement les résoudre. L'approche exposée ici n'est qu'une méthode particulière : il en existe sûrement d'autres. Elle possède donc un certain nombre d'hypothèses sur le scenario considéré. En particulier, il serait bien d'en avoir une implémentation suffisamment rapide pour être utilisé dans i-score. \\

\section{Introduction}
%TODO Blablater, citer les trucs de Simon ... Les problèmes arrivent aux conjonctions, sinon on transmet facilement l'info de proche en proche.\\

	\begin{figure}[h]
		\centering
		\input{general.tex}
		\schemaScenario general
		\caption{Schéma général d'une conjonction de deux branches}
		\label{S:general}
	\end{figure}

La figure \ref{S:general} présente un extrait de scenario, contenant une branche T0 - T3 - T4 - T5 et une autre T1 - T2 - T4 - T5. Le nœud T4 devant avoir une unique date, il s'en suit que l'exécution d'une branche va dépendre de l'autre.

	\begin{presup}
		Pour chaque contrainte, la chronologie min - défaut - max est bien assurée.
		\label{P:Chronologie}
	\end{presup}
	\begin{presup}
		Le scenario possède au moins une solution d'exécution cohérente.
		\label{P:Executabilite}
	\end{presup}
	\begin{proof}[Explication]
		Une analyse statique à l'édition suffit pour garantir ces deux hypothèses. On suppose également le scenario non modifiable par l'utilisateur pendant l'exécution.
	\end{proof}

Les contraintes portent des informations de durées, donc de dates relatives à leur début. Ce sont les valeurs auxquelles on a accès en lecture immédiate et en écriture. Or le problème de cohérence porte sur la date absolue d'un timenode. Celle ci est comprise dans un intervalle connu à l'avance par propagation des contraintes comme l'a expliqué Simon Jamain %TODO citation
et n'est donc pas modifiable directement. On note : 
	\begin{itemize}
		\item $Cx$ la durée quelconque d'une contrainte,
		\item $Cx_m$ sa durée min,
		\item $Cx_M$ sa durée max,
		\item $Tx$ la date quelconque d'un timenode,
		\item $Tx_m$ sa date min,
		\item $Tx_M$ sa date max.
	\end{itemize}

\paragraph*{}
Dans notre exemple on considère \begin{equation} T0 = T0_m = T0_M \text{ et } T1 = T1_m = T1_M \end{equation}
On peut donc déduire \begin{equation}T3_m = T0 + C1_m \text{ et } T3_M = T0 + C1_M \label{E:T3}\end{equation}
De même pour T2 \begin{equation}T2_m = T1 + C2_m \text{ et } T2_M = T1 + C2_M \label{E:T2} \end{equation}

Puisqu'on peut déduire l'intervalle d'un timenode en fonction du timenode précédent et de la contrainte qui les relie, on peut remonter récursivement ainsi jusqu'à un timenode de date connue (au plus loin il s'agira du timenode de Start, à $t=0$). Prenons exemple avec $T4$ : 
	\begin{eqnarray} 
		T4_m = T2_m + C3_m & T4_M = T2_M + C3_M \\
		T4_m = T3_m + C4_m & T4_M = T3_M + C4_M \nonumber
		\label{E:coherence}
	\end{eqnarray}

D'après (\ref{E:T3}) et (\ref{E:T2}) on a :
	\begin{eqnarray} 
		T4_m = T1 + C2_m + C3_m &
		T4_M = T1 + C2_M + C3_M \\
		T4_m = T0 + C1_m + C4_m &
		T4_M = T0 + C1_M + C4_M \nonumber
		\label{E:conjonction}
	\end{eqnarray}

Les durées des contraires étant données sans présupposé, les deux valeurs obtenus pour $T4_m$ n'ont donc aucune raison d'être identique. Cependant elles doivent l'être lors de l'exécution. Le but du ce document est donc de montrer comment recalculer les valeurs min et max des contraintes afin d'assurer une cohérence lors de l'exécution.\\

Dans le cas présenté, \textit{a priori} la modification d'une seule valeur (et donc d'une seule contrainte) suffit. Mais afin de respecter le présupposé \ref{P:Chronologie} on peut être amené à modifier deux contraintes. De plus, deux stratégies semblent s'opposer (sur leurs sémantiques) : agrandire ou réduire l'intervalle min-max, c'est à dire faire au plus flexible ou au plus restreint.

	\begin{presup}
		Les modifications effectuées ne pourront que restreindre les souplesses écrites. \label{P:modif}
	\end{presup}
	\begin{proof}[Explication]
		Dans ce cas les solutions cohérentes proposées feront parties de l'ensemble des solutions initiales, tandis que l'autre stratégie en apporte de nouvelles.
	\end{proof}

	\begin{presup}
		Chaque durée décrite par le scenario fait partie d'une solution réalisable. \label{P:coherent}
	\end{presup}
	\begin{proof}[Explication]
		Ceci peut être vérifié, et, le cas échéant, corrigé lors de l'édition (\textit{cf} section \ref{section:init} sur l'initialisation du système)
	\end{proof}

%\textbf{Correctif : } Corriger le problème de cohérence à l'édition demande une stratégie. Il faudrait donc en définir une mais je n'en trouve pas qui me plaise ...

\section{Exemple de propagation lors de l'exécution}

	\subsection{Influence du présent sur le futur}
Reprenons notre exemple initial, à une date $t>0$. On considère que $T0$ et $T1$ ont maintenant leur date effective et que le scenario est cohérent.

On peut vérifier que toutes les durées comprises dans les intervalles défnis sont réalisables, ce qu'on voit sur les figures \ref{S:coherent_min} et \ref{S:coherent_max} en prenant les valeurs extrêmes.

	\begin{figure}[htp]
	\centering
		\subfloat[Une solution du scenario cohérent (vérifie le présupposé \ref{P:coherent})]{\input{coherent.tex}
				\schemaScenario coherent
				\label{S:coherent}
		} \\
		\subfloat[Les minimums sont cohérents]{\input{coherent_min.tex}
				\schemaScenario coherent_min
				\label{S:coherent_min}
		}
		\subfloat[Les maximums sont cohérents]{\input{coherent_max.tex}
				\schemaScenario coherent_max
				\label{S:coherent_max}
		}
	\caption{Le scenario vérifie les équations (\ref{E:coherence})}
	\end{figure}

Si $T3$ est déclenché après la date $C1_m$, cela aura pour effet de repousser $T4_m$.
	
	\begin{figure}[htp]
	\centering
		\input{coherent_exec1.tex}
		\schemaScenario coherent_exec1
		\caption{Une exécution encore possible une fois $T3$ fixé}
		\label{S:coherent_exec1}
	\end{figure}

Mathématiquement on obtient :
	\begin{eqnarray}
		T4'_m &=& T4_m + T3 - T3_m \\
		T4'_M &=& T4_M + T3 - T3_M \nonumber
		\label{E:simplePropagation}
	\end{eqnarray}
	
	Par la suite on notera :
	\begin{eqnarray}
		\Delta{}_m = T3 - T3_m = T4'_m - T4_m \\
		\Delta{}_M = T3 - T3_M = T4'_M - T4_M \nonumber
		\label{E:delta}
	\end{eqnarray}

Mais comment cela influe t-il sur l'autre branche ?

	\subsection{Marche en arrière}

D'après le présupposé \ref{P:modif} on veut essayer de conserver $C2_m$ et $C2_M$, \textit{i.e.} avoir $C2'_m = C2_m$ et $C2'_M = C2_M$ . On cherche donc si il existe des valeurs de $C3$ pour lesquelles une solution est réalisable pour les valeurs extrêmes de $C2$. Littéralement, on cherche si, en prenant $C2'_m = C2_m$, $C3_M$ est assez grand pour permettre encore d'atteindre $T4'_m$, et inversement si $C3_m$ permet d'atteindre $T4$ avant son maximum.

	\begin{eqnarray}
		T4'_m < T1 + C2'_m + C3_M \\
		T1 + C2'_M + C3_m < T4'_M \nonumber
	\end{eqnarray}

Or d'après (\ref{E:conjonction}) et (\ref{E:delta}) :

	\begin{eqnarray}
		T4'_m = T4_m + \Delta{}_m = T1 + C2_m + C3_m + \Delta{}_m \\
		T4'_M = T4_M + \Delta{}_M = T1 + C2_M + C3_M + \Delta{}_M \nonumber
	\end{eqnarray}

On a donc :
	\begin{eqnarray}
		T1 + C2_m + C3_m + \Delta{}_m < T1 + C2'_m + C3_M \\
		T1 + C2_M + C3_M + \Delta{}_M > T1 + C2'_M + C3_m  \nonumber
		\label{E:comparaison}
	\end{eqnarray}

D'où :
	\begin{eqnarray}
		C2'_m = C2_m &\Rightarrow C3_M - C3_m > \Delta{}_m \\
		C2'_M = C2_M &\Rightarrow C3_M - C3_m > -\Delta{}_M \nonumber
		\label{E:absorbtion}
	\end{eqnarray}


	\begin{figure}[htp]
		\begin{center}
		\subfloat[$C2$ peut encore être min]{\label{S:coherent_exec_min} \input{coherent_exec_min.tex}
			\schemaScenario coherent_exec_min}
			\hspace{5pt}
		\subfloat[$C2$ ne peut plus être max]{\label{S:coherent_exec_max} 	\input{coherent_exec_max.tex}
			\schemaScenario coherent_exec_max}
	
		\caption{Fixer $T3$ à une date peut avoir une incidence sur $C2$}
		\end{center}
	\end{figure}

Comme on le voit en figure \ref{S:coherent_exec_max}, notre exemple aboutit à une incohérence car l'équation (\ref{E:absorbtion}) n'est pas vérifiée pour les maximums. D'après le présupposé \ref{P:modif} le seul moyen de résoudre cette incohérence est de diminuer $C2'_M$, que l'on souhaite maximum. \\
Posons : $$\Delta{C3} = C3_M - C3_m$$

En revenant sur (\ref{E:comparaison}), on obtient :

	\begin{equation}
		\Delta{}_M = C2'_M - C2_M + C3_m - C3_M \nonumber
	\end{equation}
On peut donc poser : 
	\begin{equation}
		\Delta{'}_M = C2'_M - C2_M = \Delta{}_M + \Delta{C3} 
	\end{equation}
Étant donné (\ref{E:delta}), on sait que les $\Delta{}_M$ sont négatifs. Or $\Delta{C3}$ est positif. On a donc : 
	\begin{equation}
		\Delta{}_M  \leq \Delta{'}_M  \leq 0
	\end{equation}

	\subsection{Résumé}

Fixer la date d'un timenode peut se voir comme changer sa date minimum et sa date maximum pour les rendre égales à une même date intermédiaire. On regarde alors l'influence de ce changement sur le reste du scenario en propageant la différence entre l'ancien minimum (et réciproquement maximum) qui était cohérent avec le reste et le nouveau. \\

Cette propagation se fait en deux étapes. La première est simple et consiste juste à envoyer ces deltas à la suite du scenario. Les problèmes arrivent ensuite, lorsqu'il y a une conjonction entre deux branches. Il faut alors renvoyer ces deltas vers le passé lors d'une deuxième phase, durant laquelle ils sont absorbés petit à petit jusqu'à disparition ou modification du scenario.

\section{Algorithme général}
	\subsection{Algorithme textuel}

Demande de mise à jour d'un timenode (fonction ·\textsc{UpdateTimenode}). Si jetons manquant sur une des contraintes précédentes, mise en attente du timenode. Sinon, récupération des jetons, en conservant les plus restrictifs. Mises à jour du min et max du timenode grâce à ses jetons. On observe toutes ses contraintes précédentes, on vérifie leur cohérence et on renvoie dans le passé si besoin de corriger les valeurs. On envoie ensuite dans le futur un jeton dans toutes les contraintes qui ne portaient pas de jeton arrière. On passe au timenode suivant dans la pile. \\

Une fois la pile finie, on la met à jour en faisant avancer tous les jetons (ceux qui vont de l'avant donc) des contraintes jusqu'à leur timenode. On recommence. \\

Si il reste des timenodes en attente de jeton (donc une partie de leurs contraintes précédente en ont mais pas toutes), on traite ces timenodes.\\

Enfin, on traite les contraintes contenant des jetons vers l'arrière : on demande la mise à jour de leur timenode de début.\\

On recommence du tout début tant qu'il y a des timenodes en attente.


	\subsection{Algorithme pseudo code}

Utilisation de jetons

	\begin{algorithm}
		\begin{algorithmic}[2]
			\State Vector<Timenode> tnToUpdate
			\Comment{Tn de l'étape courante}
			\State Vector<Timenode> nextStep
			\Comment {Pour les Tn mis à jour pendant l'étape courante}
			\State Vector<Timenode> tnWaiting
			\Comment {Pour les Tn en attente de jetons}
			\State Vector<Constraint> constraintsWaiting
			\Comment{Contraintes avec un jeton arrière}
			\State
			
			\While{NOT tnToUpdate empty}
			\Comment {Tant qu'on atteint des nouveaux timenodes}
				\While {NOT tnToUpdate.empty} \Comment{On va de l'avant tant que possible}
					\ForAll{tn in tnToUpdate}
						\State \Call {UpdateTimenode}{tn}
					\EndFor
					\State tnToUpdate = nextStep
					\Comment{Exploration en largeur}
					\State clear nextStep
				\EndWhile
				\State tnToUpdate = waitingTn
				\Comment {On traite ceux qui restent en attente}
				\State clear waitingTn
				\ForAll{cstr in constraintsWaiting}
				\Comment {Retour en arrière}
					\State \Call {UpdateConstraint}{cstr}
				\EndFor
			\EndWhile
		\end{algorithmic}
	\end{algorithm}
	\begin{algorithm}
		\begin{algorithmic}[2]
			
			\Function{UpdateTimenode}{Timenode Tn}
				\State Tn.token.min = 0
				\State Tn.token.max = 0
				
				\If{allPreviousToken OR wasWaiting OR backwardToken}
%				\Comment{Au dernier passage, on prend ceux qui restent}
					\ForAll {token in Tn.previousTokens}
					\Comment{Pour chaque jeton}
						\State Tn.token.min = $max$(token.min, Tn.token.min)
						\Comment{On prend le plus restrictif} 
						\State Tn.token.max = $min$(token.max, Tn.token.max)
					\EndFor
					\ForAll {token in Tn.nextTokens} 
%TODO en fait je le fait dans le Update constraint
						\State Tn.token.min = $max$(token.min, Tn.token.min)
						\State Tn.token.max = $min$(token.max, Tn.token.max)
					\EndFor
					
					\If {Tn.token.min != 0 || Tn.token.max != 0}
					\Comment {Jetons nuls stoppent la propagation}
						\State Tn.min += Tn.token.min 
						\Comment {Mise à jour du timenode}
						\State Tn.max += Tn.token.max
						\State \Call {BackwardUpdate}{Tn}
						\Comment {N'influe pas sur Tn}
						\State \Call {ForwardUpdate}{Tn}
					\EndIf
				\Else
					\State tnWaiting$.add$(timenode)
					\State continue
				\EndIf
				
			\EndFunction

		\end{algorithmic}
	\end{algorithm}
	\begin{algorithm}
		\begin{algorithmic}[2]
			\Function{BackwardUpdate}{Timenode Tn}
			\Comment{Retour arrière si nécessaire}
				\ForAll {cstr in Tn.previousConstraints}
					\State deltaMin = Tn.min - (cstr.min + cstr.startTn.min)
					\If{deltaMin > 0}
					\Comment {Si une incohérence est apparue}
						\State cstr.token.min = deltaMin
						\State constraintsWaiting.$add$(cstr)
						\Comment {Envoi d'un jeton vers l'arrière}
					\EndIf
					\State deltaMax = Tn.max - (cstr.max + cstr.startTn.max)
					\If {deltaMax < 0}
						\State cstr.token.max = deltaMax
						\State constraintsWaiting.$add$(cstr)
						\Comment{Envoi d'un jeton vers l'arrière}
					\EndIf
				\EndFor
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	\begin{algorithm}
		\begin{algorithmic}[2]
			\Function{ForwardUpdate}{Timenode Tn}
				\ForAll {cstr in Tn.nextConstraints}
					\Comment {Propagation vers le futur}
					\State cstr.token = Tn.token
					\State nextStep$.add$(cstr.endTimenode)
					\Comment {Envoi d'un jeton vers l'avant}
				\EndFor			
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	\begin{algorithm}
		\begin{algorithmic}[2]
			\Function{UpdateConstraint}{Constraint cstr}

				\If {startTn Happened}
				\Comment{mise à jour du min et max}
					\State cstr.min += cstr.token.min
					\State cstr.max += cstr.token.max
				\ElsIf {cstr.max - cstr.min < cstr.token.min}
				\Comment {min en partie absorbable}
					\State startTn.token.min = cstr.token.min - (cstr.max - cstr.min)
					\State waitingtn$.add$(startTn)
				\ElsIf {cstr.max - cstr.min < - cstr.token.max}
				\Comment {max en partie absorbable}
					\State startTn.token.max = cstr.token.max + (cstr.max - cstr.min)
					\State waitingTn$.add$(startTn)
				\EndIf
				\Comment {Sinon, deltas totalement absorbés}
			\EndFunction
		\end{algorithmic}
	\end{algorithm}

\newpage
\section{Initialisation du système}
\label{section:init}

%Pour initialiser le système et obtenir un premier scenario cohérent, on peut utiliser un algorithme similaire. On envoie des jetons nuls vers l'avant, uniquement quand toutes les contraintes précédentes sont cohérentes. Sinon on envoie des jetons correctifs en arrière jusqu'à un timenode cohérent pour mettre à jour les contraintes et on relance l'algorithme.\\

%La première fois seul le start Tn est cohérent, ensuite on arrêtera le retour arrière à la première conjonction rencontrée.

\section{Limites connues}

	\subsection{Modification du passé}

	\begin{figure}[htp]
		\centering
		\input{modif_passe.tex}
		\schemaScenario modif_passe
		\caption{}
		\label{S:modif_passe}
	\end{figure}

Le scenario \ref{S:modif_passe} est cohérent et respecte les hypothèses posées dans le présent document. Néanmoins, il se pose un problème de causalité : le timenode 3 ne peut pas être celui qui sera fixé à l'exécution. Ce problème doit donc être résolu en amont, sinon l'algorithme présenté ici risque de proposer une maximum passé pour la contrainte $C1$.

%TODO souplesse sans trigger possible ! Trigger sans souplesse aussi mais peu d'interet

	\subsection{Désactivation d'une branche}
%TODO desactivation branche
Y a t'il plus simple qu'une nouvelle initialisation ?

\end{document}