\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{amsthm}
\usepackage{subfig}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[left=2.0cm, right=2.0cm, top=2.50cm, bottom=2.5cm]{geometry}
\author{Nicolas VUAILLE}
\title{Algorithme de propagation}
\date{\today}

\newtheorem{presup}{Hypothèse}

\begin{document}
\maketitle

\section*{Abstract}

La cohérence temporelle d'un scenario interactif est un problème épineux. Si une analyse statique permet déjà de voir les potentiels problèmes, une correction en amont n'est pas forcément bienvenue : le fait d'avoir des branches conditionnelles peut lors de l'exécution libérer le scenario de certaines contraintes et rendre possible des exécutions qui ne le semblaient pas. Une analyse lors de l'exécution est donc nécessaire. \\

Cependant il semble que l'on ai assez d'informations pour anticiper les problèmes, et potentiellement les résoudre. L'approche exposée ici n'est qu'une méthode particulière : il en existe sûrement d'autres. Elle possède donc un certain nombre d'hypothèses sur le scenario considéré. En particulier, il serait bien d'en avoir une implémentation suffisamment rapide pour être utilisé dans i-score. \\

\section{Introduction}
%TODO Blablater, citer les trucs de Simon ... Les problèmes arrivent aux conjonctions, sinon on transmet facilement l'info de proche en proche.\\

	\begin{figure}[h]
		\centering
		\input{general.tex}
		\schemaScenario general
		\caption{Schéma général d'une conjonction de deux branches}
		\label{S:general}
	\end{figure}

La figure \ref{S:general} présente un extrait de scenario, contenant une branche T0 - T3 - T4 - T5 et une autre T1 - T2 - T4 - T5. Le nœud T4 devant avoir une unique date, il s'en suit que l'exécution d'une branche va dépendre de l'autre.

	\begin{presup}
		Pour chaque contrainte, la chronologie min - défaut - max est bien assurée.
		\label{P:Chronologie}
	\end{presup}
	\begin{presup}
		Le scenario possède au moins une solution d'exécution cohérente.
		\label{P:Executabilite}
	\end{presup}
	\begin{proof}[Explication]
		Une analyse statique à l'édition suffit pour garantir ces deux hypothèses. On suppose également le scenario non modifiable par l'utilisateur pendant l'exécution.
	\end{proof}

Les contraintes portent des informations de durées, donc de dates relatives à leur début. Ce sont les valeurs auxquelles on a accès en lecture immédiate et en écriture. Or le problème de cohérence porte sur la date absolue d'un timenode. Celle ci est comprise dans un intervalle connu à l'avance par propagation des contraintes comme l'a expliqué Simon Jamain %TODO citation
et n'est donc pas modifiable directement. On note : 
	\begin{itemize}
		\item $Cx$ la durée quelconque d'une contrainte,
		\item $Cx_m$ sa durée min,
		\item $Cx_M$ sa durée max,
		\item $Tx$ la date quelconque d'un timenode,
		\item $Tx_m$ sa date min,
		\item $Tx_M$ sa date max.
	\end{itemize}

\paragraph*{}
Dans notre exemple on considère \begin{equation} T0 = T0_m = T0_M \text{ et } T1 = T1_m = T1_M \end{equation}
On peut donc déduire \begin{equation}T3_m = T0 + C1_m \text{ et } T3_M = T0 + C1_M \label{E:T3}\end{equation}
De même pour T2 \begin{equation}T2_m = T1 + C2_m \text{ et } T2_M = T1 + C2_M \label{E:T2} \end{equation}

Puisqu'on peut déduire l'intervalle d'un timenode en fonction du timenode précédent et de la contrainte qui les relie, on peut remonter récursivement ainsi jusqu'à un timenode de date connue (au plus loin il s'agira du timenode de Start, à $t=0$). Prenons exemple avec $T4$ : 
	\begin{eqnarray} 
		T4_m = T2_m + C3_m & T4_M = T2_M + C3_M \\
		T4_m = T3_m + C4_m & T4_M = T3_M + C4_M \nonumber
		\label{E:coherence}
	\end{eqnarray}

D'après (\ref{E:T3}) et (\ref{E:T2}) on a :
	\begin{eqnarray} 
		T4_m = T1 + C2_m + C3_m &
		T4_M = T1 + C2_M + C3_M \\
		T4_m = T0 + C1_m + C4_m &
		T4_M = T0 + C1_M + C4_M \nonumber
		\label{E:conjonction}
	\end{eqnarray}

Les durées des contraires étant données sans présupposé, les deux valeurs obtenus pour $T4_m$ n'ont donc aucune raison d'être identique. Cependant elles doivent l'être lors de l'exécution. Le but du ce document est donc de montrer comment recalculer les valeurs min et max des contraintes afin d'assurer une cohérence lors de l'exécution.\\

Dans le cas présenté, \textit{a priori} la modification d'une seule valeur (et donc d'une seule contrainte) suffit. Mais afin de respecter le présupposé \ref{P:Chronologie} on peut être amené à modifier deux contraintes. De plus, deux stratégies semblent s'opposer (sur leurs sémantiques) : agrandire ou réduire l'intervalle min-max, c'est à dire faire au plus flexible ou au plus restreint.

	\begin{presup}
		Les modifications effectuées ne pourront que restreindre les souplesses écrites. \label{P:modif}
	\end{presup}
	\begin{proof}[Explication]
		Dans ce cas les solutions cohérentes proposées feront parties de l'ensemble des solutions initiales, tandis que l'autre stratégie en apporte de nouvelles.
	\end{proof}

	\begin{presup}
		Chaque durée décrite par le scenario fait partie d'une solution réalisable. \label{P:coherent}
	\end{presup}
	\begin{proof}[Explication]
		Ceci peut être vérifié, et, le cas échéant, corrigé lors de l'édition.
	\end{proof}

\section{Exemple de propagation lors de l'exécution}

	\subsection{Influence du présent sur le futur}
Reprenons notre exemple initial, à une date $t>0$. On considère que $T0$ et $T1$ ont maintenant leur date effective et que le scenario est cohérent.

On peut vérifier que toutes les durées comprises dans les intervalles défnis sont réalisables, ce qu'on voit sur les figures \ref{S:coherent_min} et \ref{S:coherent_max} en prenant les valeurs extrêmes.

	\begin{figure}[htp]
	\centering
		\subfloat[Une solution du scenario cohérent (vérifie le présupposé \ref{P:coherent})]{\input{coherent.tex}
				\schemaScenario coherent
				\label{S:coherent}
		} \\
		\subfloat[Les minimums sont cohérents]{\input{coherent_min.tex}
				\schemaScenario coherent_min
				\label{S:coherent_min}
		}
		\subfloat[Les maximums sont cohérents]{\input{coherent_max.tex}
				\schemaScenario coherent_max
				\label{S:coherent_max}
		}
	\caption{Le scenario vérifie les équations (\ref{E:coherence})}
	\end{figure}

Si $T3$ est déclenché après la date $C1_m$, cela aura pour effet de repousser $T4_m$.
	
	\begin{figure}[htp]
	\centering
		\input{coherent_exec1.tex}
		\schemaScenario coherent_exec1
		\caption{Une exécution encore possible une fois $T3$ fixé}
		\label{S:coherent_exec1}
	\end{figure}

Mathématiquement on obtient :
	\begin{eqnarray}
		T4'_m &=& T4_m + T3 - T3_m \\
		T4'_M &=& T4_M + T3 - T3_M \nonumber
		\label{E:simplePropagation}
	\end{eqnarray}
	
	Par la suite on notera :
	\begin{eqnarray}
		\Delta{}_m = T3 - T3_m = T4'_m - T4_m \\
		\Delta{}_M = T3 - T3_M = T4'_M - T4_M \nonumber
		\label{E:delta}
	\end{eqnarray}

Mais comment cela influe t-il sur l'autre branche ?

	\subsection{Marche en arrière}

D'après le présupposé \ref{P:modif} on veut essayer de conserver $C2_m$ et $C2_M$, \textit{i.e.} avoir $C2'_m = C2_m$ et $C2'_M = C2_M$ . On cherche donc si il existe des valeurs de $C3$ pour lesquelles une solution est réalisable pour les valeurs extrêmes de $C2$. Littéralement, on cherche si, en prenant $C2'_m = C2_m$, $C3_M$ est assez grand pour permettre encore d'atteindre $T4'_m$, et inversement si $C3_m$ permet d'atteindre $T4$ avant son maximum.

	\begin{eqnarray}
		T4'_m < T1 + C2'_m + C3_M \\
		T1 + C2'_M + C3_m < T4'_M \nonumber
	\end{eqnarray}

Or d'après (\ref{E:conjonction}) et (\ref{E:delta}) :

	\begin{eqnarray}
		T4'_m = T4_m + \Delta{}_m = T1 + C2_m + C3_m + \Delta{}_m \\
		T4'_M = T4_M + \Delta{}_M = T1 + C2_M + C3_M + \Delta{}_M \nonumber
	\end{eqnarray}

On a donc :
	\begin{eqnarray}
		T1 + C2_m + C3_m + \Delta{}_m < T1 + C2'_m + C3_M \\
		T1 + C2_M + C3_M + \Delta{}_M > T1 + C2'_M + C3_m  \nonumber
		\label{E:comparaison}
	\end{eqnarray}

D'où :
	\begin{eqnarray}
		C2'_m = C2_m &\Rightarrow C3_M - C3_m > \Delta{}_m \\
		C2'_M = C2_M &\Rightarrow C3_M - C3_m > -\Delta{}_M \nonumber
		\label{E:absorbtion}
	\end{eqnarray}


	\begin{figure}[htp]
		\begin{center}
		\subfloat[$C2$ peut encore être min]{\label{S:coherent_exec_min} \input{coherent_exec_min.tex}
			\schemaScenario coherent_exec_min}
			\hspace{5pt}
		\subfloat[$C2$ ne peut plus être max]{\label{S:coherent_exec_max} 	\input{coherent_exec_max.tex}
			\schemaScenario coherent_exec_max}
	
		\caption{Fixer $T3$ à une date peut avoir une incidence sur $C2$}
		\end{center}
	\end{figure}

Comme on le voit en figure \ref{S:coherent_exec_max}, notre exemple aboutit à une incohérence car l'équation (\ref{E:absorbtion}) n'est pas vérifiée pour les maximums. D'après le présupposé \ref{P:modif} le seul moyen de résoudre cette incohérence est de diminuer $C2'_M$, que l'on souhaite maximum. \\
Posons : $$\Delta{C3} = C3_M - C3_m$$

En revenant sur (\ref{E:comparaison}), on obtient :

	\begin{equation}
		\Delta{}_M = C2'_M - C2_M + C3_m - C3_M \nonumber
	\end{equation}
On peut donc poser : 
	\begin{equation}
		\Delta{'}_M = C2'_M - C2_M = \Delta{}_M + \Delta{C3} 
	\end{equation}
Étant donné (\ref{E:delta}), on sait que les $\Delta{}_M$ sont négatifs. Or $\Delta{C3}$ est positif. On a donc : 
	\begin{equation}
		\Delta{}_M  \leq \Delta{'}_M  \leq 0
	\end{equation}

	\subsection{Résumé}

Fixer la date d'un timenode peut se voir comme changer sa date minimum et sa date maximum pour les rendre égales à une même date intermédiaire. On regarde alors l'influence de ce changement sur le reste du scenario en propageant la différence entre l'ancien minimum (et réciproquement maximum) qui était cohérent avec le reste et le nouveau. \\

Cette propagation se fait en deux étapes. La première est simple et consiste juste à envoyer ces deltas à la suite du scenario. Les problèmes arrivent ensuite, lorsqu'il y a une conjonction entre deux branches. Il faut alors renvoyer ces deltas vers le passé lors d'une deuxième phase, durant laquelle ils sont absorbés petit à petit jusqu'à disparition ou modification du scenario.

\section{Algorithme général}
	\subsection{Algorithme textuel}

Lorsqu'un timenode est fixé, on propage on $\Delta{}_m$ et un $\Delta{}_M$ : on passe par ses contraintes suivantes pour atteindre de nouveaux timenodes. Les valeurs min et max de ces timenodes sont alors mises à jour. Ensuite plusieurs cas de figure : 
	\begin{enumerate}
		\item Toutes les contraintes précédentes sont cohérentes (elles ont apportés les deltas) : on transmet les deltas aux contraintes suivantes.
		\item Certaines contraintes précédentes ne sont plus cohérentes : on leur transmet les deltas pour aller modifier le scenario en amont. Une fois ces modifications faites, on peut repartir de l'avant.
	\end{enumerate}

	\subsection{Algorithme pseudo code}

Utilisation de jetons

	\begin{algorithm}
		\begin{algorithmic}[2]
			\State Vector<Timenode> tnToUpdate
			\Comment{Tn de l'étape courante}
			\State Vector<Timenode> nextStep
			\Comment {Pour les Tn mis à jour pendant l'étape courante}
			\State Vector<Timenode> tnWaiting
			\Comment {Pour les Tn en attente de jetons}
			\State Vector<Constraint> constraintsWaiting
			\Comment{Contraintes avec un jeton arrière}
			\State
			
			\While{NOT tnToUpdate empty}
				\While {NOT tnToUpdate.empty} \Comment{On va de l'avant tant que possible}
					\ForAll{tn in tnToUpdate}
						\State \Call {UpdateTimenode}{tn}
					\EndFor
					\State tnToUpdate = nextStep
					\Comment{Exploration en largeur}
					\State clear nextStep
				\EndWhile
				\State tnToUpdate = waitingTn
				\State clear waitingTn
				\ForAll{cstr in constraintsWaiting}
					\State \Call {UpdateConstraint}{cstr}
				\EndFor
			\EndWhile
		\end{algorithmic}
	\end{algorithm}
	\begin{algorithm}
		\begin{algorithmic}[2]
			
			\Function{UpdateTimenode}{Timenode Tn}
				\State Tn.token.min = 0
				\State Tn.token.max = 0
				
				\If{allPreviousToken OR waiting OR backwardToken}
%				\Comment{Au dernier passage, on prend ceux qui restent}
					\ForAll {token in Tn.previousTokens}
					\Comment{Pour chaque jeton}
						\State Tn.token.min = $max$(token.min, Tn.token.min)
						\Comment{On prend le plus restrictif} 
						\State Tn.token.max = $min$(token.max, Tn.token.max)
					\EndFor
					\ForAll {token in Tn.nextTokens} 
						\State Tn.token.min = $max$(token.min, Tn.token.min)
						\State Tn.token.max = $min$(token.max, Tn.token.max)
					\EndFor
					
					\If {Tn.token.min != 0 || Tn.token.max != 0}
					\Comment {Jetons nuls stoppent la propagation}
						\State Tn.min += Tn.token.min 
						\Comment {Mise à jour du timenode}
						\State Tn.max += Tn.token.max
						\State \Call {BackwardUpdate}{Tn}
						\Comment {N'influe pas sur Tn}
						\State \Call {ForwardUpdate}{Tn}
					\EndIf
				\Else
					\State tnWaiting$.add$(timenode)
					\State continue
				\EndIf
				
			\EndFunction

		\end{algorithmic}
	\end{algorithm}
	\begin{algorithm}
		\begin{algorithmic}[2]
			\Function{BackwardUpdate}{Timenode Tn}
			\Comment{Retour arrière si nécessaire}
				\ForAll {cstr in Tn.previousConstraints}
					\State deltaMin = Tn.min - (cstr.min + cstr.startTn.min)
					\If{deltaMin > 0}
					\Comment {Si une incohérence est apparue}
						\State cstr.token.min = deltaMin
						\State constraintsWaiting.$add$(cstr)
						\Comment {Envoi d'un jeton vers l'arrière}
					\EndIf
					\State deltaMax = Tn.max - (cstr.max + cstr.startTn.max)
					\If {deltaMax < 0}
						\State cstr.token.max = deltaMax
						\State constraintsWaiting.$add$(cstr)
						\Comment{Envoi d'un jeton vers l'arrière}
					\EndIf
				\EndFor
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	\begin{algorithm}
		\begin{algorithmic}[2]
			\Function{ForwardUpdate}{Timenode Tn}
				\ForAll {cstr in Tn.nextConstraints}
					\Comment {Propagation vers le futur}
					\State cstr.token = Tn.token
					\State nextStep$.add$(cstr.endTimenode)
					\Comment {Envoi d'un jeton vers l'avant}
				\EndFor			
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	\begin{algorithm}
		\begin{algorithmic}[2]
			\Function{UpdateConstraint}{Constraint cstr}

				\If {startTn Happened}
				\Comment{mise à jour du min et max}
					\State cstr.min += cstr.token.min
					\State cstr.max += cstr.token.max
				\ElsIf {cstr.max - cstr.min < cstr.token.min}
				\Comment {min en partie absorbable}
					\State startTn.token.min = cstr.token.min - (cstr.max - cstr.min)
					\State waitingtn$.add$(startTn)
				\ElsIf {cstr.max - cstr.min < - cstr.token.max}
				\Comment {max en partie absorbable}
					\State startTn.token.max = cstr.token.max + (cstr.max - cstr.min)
					\State waitingTn$.add$(startTn)
				\EndIf
			\EndFunction
		\end{algorithmic}
	\end{algorithm}

\newpage
\section{Initialisation du système}
Pour initialiser le système et obtenir un premier scenario cohérent, on peut passer l'algorithme décrit pour l'exécution en lançant des jetons nuls depuis le timenode de début de scenario et en arrêtant pas la propagation vers le futur lorsque les jetons sont nuls.

\section{Limites connues}

	\subsection{Modification du passé}

	\begin{figure}[htp]
		\centering
		\input{modif_passe.tex}
		\schemaScenario modif_passe
		\caption{}
		\label{S:modif_passe}
	\end{figure}
	
Le scenario \ref{S:modif_passe} est cohérent et respecte les hypothèses posées dans le présent document. Néanmoins, il se pose un problème de causalité : le timenode 3 ne peut pas être celui qui sera fixé à l'exécution.

	\subsection{Désactivation d'une branche}
%TODO desactivation branche

\end{document}